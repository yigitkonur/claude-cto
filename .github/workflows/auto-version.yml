name: Auto Version Management

on:
  workflow_dispatch:
    inputs:
      bump_type:
        description: 'Version bump type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
        default: 'patch'
      custom_version:
        description: 'Custom version (e.g., 1.2.3) - overrides bump_type if set'
        required: false
        type: string
      skip_release:
        description: 'Only bump version, skip release'
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  id-token: write

jobs:
  bump-version:
    name: Bump Version and Create Release
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.bump.outputs.new_version }}
      should_release: ${{ steps.bump.outputs.should_release }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'
    
    - name: Configure Git
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
    
    - name: Bump version
      id: bump
      run: |
        # Make script executable
        chmod +x scripts/bump_version.py
        
        # Determine version argument
        if [[ -n "${{ github.event.inputs.custom_version }}" ]]; then
          VERSION_ARG="${{ github.event.inputs.custom_version }}"
        else
          VERSION_ARG="${{ github.event.inputs.bump_type }}"
        fi
        
        echo "Bumping version with argument: $VERSION_ARG"
        
        # Run version bump script (non-interactive)
        python scripts/bump_version.py "$VERSION_ARG" --no-tag --ci
        
        # Get the new version
        NEW_VERSION=$(python -c "import claude_cto; print(claude_cto.__version__)")
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
        
        # Determine if we should release
        if [[ "${{ github.event.inputs.skip_release }}" == "true" ]]; then
          echo "should_release=false" >> $GITHUB_OUTPUT
        else
          echo "should_release=true" >> $GITHUB_OUTPUT
        fi
        
        echo "New version: $NEW_VERSION"
    
    - name: Create and push tag
      if: steps.bump.outputs.should_release == 'true'
      run: |
        NEW_VERSION="${{ steps.bump.outputs.new_version }}"
        
        # Check if tag already exists
        if git tag -l | grep -q "^v$NEW_VERSION$"; then
          echo "Tag v$NEW_VERSION already exists, skipping tag creation"
        else
          git tag "v$NEW_VERSION"
          echo "Created tag v$NEW_VERSION"
        fi
        
        git push origin main
        
        # Push tag only if it was created or doesn't exist on remote
        git push origin "v$NEW_VERSION" || echo "Tag v$NEW_VERSION already exists on remote"
        echo "Pushed changes for version v$NEW_VERSION"
    
    - name: Push version-only changes
      if: steps.bump.outputs.should_release == 'false'
      run: |
        git push origin main
        echo "Pushed version bump without creating release tag"
  
  # Trigger the release workflow if we created a tag
  trigger-release:
    name: Trigger Release Pipeline
    needs: bump-version
    if: needs.bump-version.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    steps:
    - name: Wait for tag to be available
      run: sleep 10
    
    - name: Trigger release workflow
      uses: peter-evans/repository-dispatch@v3
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        repository: ${{ github.repository }}
        event-type: release-triggered
        client-payload: '{"version": "${{ needs.bump-version.outputs.new_version }}"}'